# vi: set filetype=sh:

if [[ -x "$(builtin command -v rg)" ]]; then
    FZF_DEFAULT_COMMAND='rg --files --no-ignore -L -g "!.git/" 2>/dev/null'
elif [[ -x "$(builtin command -v ag)" ]]; then
    FZF_DEFAULT_COMMAND='ag -u --ignore ".git" -l -g ""'
else
    FZF_DEFAULT_COMMAND='find . -path "*/\.*" -prune -o -type f -print -o -type l -print | sed s/^..// 2>/dev/null'
fi
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

# Show command history with short command descriptions in the preview window.
export FZF_CTRL_R_OPTS="--preview='echo {} | cut -d"'" "'" -f3 | xargs whatis' --preview-window=down:5"

FZF_DEFAULT_OPTS='--reverse '
FZF_DEFAULT_OPTS+='-m '
FZF_DEFAULT_OPTS+='--cycle '

# Note: bat provides syntax highlighting.
FZF_DEFAULT_OPTS+="--preview='(file --mime {} | grep -q -s empty && echo \$(basename {}): is empty.) ||
    (file --mime {} | grep -q -s binary && echo \$(basename {}): is a binary file.) ||
    (bat --style=numbers --color=always {} | head -500)' "
    FZF_DEFAULT_OPTS+='--preview-window="down:50%:hidden" '


# Keyboard mappings.
FZF_DEFAULT_OPTS+='--bind="?:toggle-preview" '
FZF_DEFAULT_OPTS+='--bind="ctrl-n:down" '
FZF_DEFAULT_OPTS+='--bind="ctrl-p:up" '
FZF_DEFAULT_OPTS+='--bind="ctrl-alt-p:page-up" '
FZF_DEFAULT_OPTS+='--bind="ctrl-alt-n:page-down" '
FZF_DEFAULT_OPTS+='--bind="change:top" '
FZF_DEFAULT_OPTS+='--bind="ctrl-r:toggle-sort" '
FZF_DEFAULT_OPTS+='--bind="ctrl-g:kill-line" '

# # Colorscheme.
export FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS \
--color=fg:#c0caf5,bg:#1a1b26,hl:#ff9e64 \
--color=fg+:#c0caf5,bg+:#292e42,hl+:#ff9e64 \
--color=info:#7aa2f7,prompt:#7dcfff,pointer:#7dcfff \
--color=marker:#9ece6a,spinner:#9ece6a,header:#9ece6a"

export FZF_COMPLETION_OPTS="--height='40%'"

# The command that opens default applications depending on the mime type of the file.
export OPENER="$([ $(uname -s) == 'Darwin' ] && command -v open || command -v xdg-open)"


builtin bind '"\C-x0": kill-whole-line'     # Clears the entire line.
builtin bind '"\C-x1": magic-space'         # Performs history expansion and inserts a space.
builtin bind '"\C-x2": redraw-current-line' # Refreshes the current line.


# Prints the command to the command-line so that command-line history is logged.
__ehc() {
    READLINE_LINE="${READLINE_LINE:+${READLINE_LINE:0:READLINE_POINT}}${1}${READLINE_LINE:+${READLINE_LINE:READLINE_POINT}}"
    READLINE_POINT="$((READLINE_POINT + ${#1}))"
}

__build_edit_command() {
    local key tool file line checkout optstring option
    key='default'
    tool=""
    file=""
    line=""
    checkout=""
    optstring=':k:t:f:l:c:'
    while getopts "$optstring" option; do
        case $option in
            k) key="${OPTARG}" ;;
            t) tool="${OPTARG}" ;;
            f) file="${OPTARG}" ;;
            l) line="+${OPTARG}" ;;
            c) checkout="git checkout ${OPTARG};" ;;
            *) builtin printf "%s\\n" "fzf_bindings: flag '$OPTARG' doesn't exist. Terminating."; return 1 ;;
        esac
    done

    # Allocate the command namespace.
    local _command=""

    [[ -n "$tool" ]] && _command="$tool"

    # Build the command.
    [[ -n "$file" ]] && _command="${_command} ${file}"

    if [[ -n "$checkout" ]]; then
        _command="${checkout} ${_command}"
    fi

    [[ -n "$line" ]] && _command="${_command} ${line}"

    # Choose the operation.
    case $key in
        'alt-c')
            _command="builtin cd ${file%/*}"
            if [[ -n $checkout ]]; then
                _command="${checkout} ${_command}"
            fi
            ;;
        'ctrl-o')
            if [[ -n "$OPENER" ]]; then
                _command="${OPENER} '$file'"
            else
                # Attempt to determine open-utility on the fly.
                local os kernel_name
                kernel_name="$(command uname -s)"
                case "${kernel_name}" in
                    'Linux' | 'GNU'*)
                        os='linux' ;;
                    'Darwin')
                        os="$(command sw_vers -productName)" ;;
                    *'BSD')
                        os='bsd' ;;
                    'CYGWIN'* | 'MSYS'* | 'MINGW'*)
                        os='windows' ;;
                    'SunOS')
                        os='solaris' ;;
                    *)
                        os='unknown'
                        ;;
                esac
                case "${os}" in
                    'linux' | 'bsd')
                        _command="xdg-open '$file'" ;;
                    'macOS')
                        _command="open \"$file\"" ;;
                    'windows')
                        _command="start '$file'" ;;
                    *)
                        printf "%s\\n" "Unknown Operating System detected: \"${kernel_name}\". Terminating." 1>&2
                        return 1
                esac
            fi
            ;;
        'ctrl-s')
            _command="sudo ${_command}"
            ;;
        'ctrl-x')
            [[ -n "$TMUX" ]] || { builtin printf "%s\\n" 'fzf_bindings: Tmux session not detected. Terminating.' 2>&1; return 1; }
            _command="tmux split-window -v \"${_command}; exec bash\""
            ;;
        'ctrl-v')
            [[ -n "$TMUX" ]] || { builtin printf "%s\\n" 'fzf_bindings: Tmux session not detected. Terminating.' 2>&1; return 1; }
            _command="tmux split-window -h \"${_command}; exec bash\""
            ;;
        'ctrl-t')
            [[ -n "$TMUX" ]] || { builtin printf "%s\\n" 'fzf_bindings: Tmux session not detected. Terminating.' 2>&1; return 1; }
            _command="tmux new-window \"${_command}; exec bash\""
            ;;
    esac

    builtin echo "$_command"
}

__catch_interrupt() {
    trap '' ERR INT TERM QUIT

    if [[ -n "$1" ]]; then
        builtin cd -- "$1"
    fi
    return
}


# Press "Ctrl-x + Ctrl-x" to open a file below the current filepath.
__fzf_file_open() {
    local cwd selection key file
    cwd="$(pwd)"
    selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
        command fzf --height='40%' -0 --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c')")
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    file="$(command head -2 <<< "$selection" | command tail -1)"

    local path
    if [[ -n "$dir" ]]; then
        path="${dir}/${file}"
    else
        path="${file}"
    fi

    [[ -f "$path" ]] || { builtin cd -- "$cwd"; return 1; }

    local _command
    _command="$(__build_edit_command -k "$key" -t "$EDITOR" -f "$path")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"
}
builtin bind -x '"\C-_00": __fzf_file_open'
builtin bind -m vi-insert '"\C-x\C-x": "\C-x0\C-_00\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x\C-x": "i\C-x0\C-_00\C-x1\C-x2\015"'


# Press "Ctrl-x + x" to open any file under the root folder in a git-tracked project.
__fzf_git_project_file_open() {
    local cwd
    cwd="$(pwd)"
    trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
    local dir=""
    if git rev-parse --show-toplevel &>/dev/null; then
        dir="$(git rev-parse --show-toplevel)"
        builtin cd -- "$dir"
    else
        builtin printf "%s\\n" "__fzf_git_project_file_open: Not in a git-tracked project" 2>&1
        return 1
    fi

    local selection key file
    selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
        command fzf --height='40%' -0 --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c')")
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then
        builtin cd -- "$cwd"
        return 127
    fi
    file="$(command head -2 <<< "$selection" | command tail -1)"

    local path
    if [[ -n "$dir" ]]; then
        path="${dir}/${file}"
    else
        path="${file}"
    fi

    [[ -f "$path" ]] || { builtin cd -- "$cwd"; return 1; }

    local _command
    _command="$(__build_edit_command -k "$key" -t "$EDITOR" -f "$path")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    builtin cd -- "$cwd"

    [[ $key != 'alt-c' ]] && builtin cd -- "$cwd"
    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_01": __fzf_git_project_file_open'
builtin bind -m vi-insert '"\C-xx": "\C-x0\C-_01\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-xx": "i\C-x0\C-_01\C-x1\C-x2\015"'


# Press "Ctrl-g + H" to search for and select a git commit hash.
__fzf_search_git_hashes() {
    if git rev-parse --show-toplevel &>/dev/null; then
        local path
        path="$(git rev-parse --show-toplevel)"
    else
        builtin printf "%s\\n" "__fzf_search_git_hashes: Git project not detected." 2>&1
        return 1
    fi

    local fzf_output key selection commit_hash file file_path
    fzf_output=("$(git log --oneline | fzf --height='60%' --preview 'echo \"Commit: {1}\" && echo && git show --color=always --format=fuller --stat {1}' --preview-window=down:50%:wrap -0 --expect='ctrl-x,ctrl-v,ctrl-t,ctrl-c')")

    # fzf_output=("$(git log --oneline | fzf --height='40%' -0 --expect='ctrl-x,ctrl-v,ctrl-t,ctrl-c')")
    key="$(command head -1 <<< "$fzf_output")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    [[ -z "$key" ]] && key='default'
    selection="$(command head -2 <<< "$fzf_output" | command tail -1)"
    commit_hash="$(echo $selection | awk '{ print $1 }')"

    # Verify the commit hash.
    local hash_regex='^[0-9a-f]{7,40}'
    if [[ $commit_hash =~ $hash_regex ]]; then
        commit_hash="${BASH_REMATCH[@]}"
    fi

    __ehc "$commit_hash"
}
builtin bind -x '"\C-_02": __fzf_search_git_hashes'
builtin bind -m vi-insert '"\C-gH": "\C-_02"'
builtin bind -m vi-command '"\C-gH": "i\C-_02"'


# Press "Ctrl-g + ch" to `git checkout` a commit.
__fzf_checkout_commit() {
    if git rev-parse --show-toplevel &>/dev/null; then
        local path
        path="$(git rev-parse --show-toplevel)"
    else
        builtin printf "%s\\n" "__fzf_checkout_commit: Git project not detected." 2>&1
        return 1
    fi

    local fzf_output key selection commit_hash file file_path
    fzf_output=("$(git log --oneline | fzf --height='40%' -0 --expect='ctrl-x,ctrl-v,ctrl-t,ctrl-c')")
    key="$(command head -1 <<< "$fzf_output")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    [[ -z "$key" ]] && key='default'
    selection="$(command head -2 <<< "$fzf_output" | command tail -1)"
    commit_hash="$(echo $selection | awk '{ print $1 }')"

    # Verify the commit hash.
    local hash_regex='^[0-9a-f]{7,40}'
    if [[ $commit_hash =~ $hash_regex ]]; then
        commit_hash="${BASH_REMATCH[@]}"
    fi


    local _command
    _command="$(__build_edit_command -k "$key" -c "$commit_hash")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"
}
builtin bind -x '"\C-_03": __fzf_checkout_commit'
builtin bind -m vi-insert '"\C-gch": "\C-x0\C-_03\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gch": "i\C-x0\C-_03\C-x1\C-x2\015"'


# Press "Ctrl-g + cb" to `git checkout` a branch.
__fzf_checkout_branch() {
    if git rev-parse --show-toplevel &>/dev/null; then
        local path
        path="$(git rev-parse --show-toplevel)"
    else
        builtin printf "%s\\n" "Git project not detected." 2>&1
        return 1
    fi

    local fzf_output key selection commit_hash file file_path
    fzf_output=("$(git branch | fzf --height='40%' -0 --expect='ctrl-x,ctrl-v,ctrl-t,ctrl-c' | tr -d '[:space:]')")
    key="$(command head -1 <<< "$fzf_output")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    [[ -z "$key" ]] && key='default'
    selection="$(command head -2 <<< "$fzf_output" | command tail -1)"
    commit_hash="$(echo $selection | awk '{ print $1 }')"

    # Verify the commit hash.
    local hash_regex='^[0-9a-f]{7,40}'
    if [[ $commit_hash =~ $hash_regex ]]; then
        commit_hash="${BASH_REMATCH[@]}"
    fi


    local _command
    _command="$(__build_edit_command -k "$key" -c "$commit_hash")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"
}
builtin bind -x '"\C-_04": __fzf_checkout_branch'
builtin bind -m vi-insert '"\C-gcb": "\C-x0\C-_04\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gcb": "i\C-x0\C-_04\C-x1\C-x2\015"'


# Press "Ctrl-g + cf" to open a file from the previous commit.
__fzf_open_file_at_commit() {
    if git rev-parse --show-toplevel &>/dev/null; then
        local path
        path="$(git rev-parse --show-toplevel)"
    else
        builtin printf "%s\\n" "__fzf_open_file_at_commit: Git project not detected." 2>&1
        return 1
    fi

    # Get number of commits.
    local commit_count
    commit_count="$(git rev-list --no-merges --count HEAD --)"
    commit_count=$((commit_count - 1))

    # Build array of file diffs paired with their respective commit hashes.
    local selections hash_regex commit_file _hash message
    hash_regex='(^[0-9a-f]{7,40})\ (.*)'
    while read -r commit_file; do
        if [[ $commit_file =~ $hash_regex ]]; then
            _hash="${BASH_REMATCH[1]}"
            message="${BASH_REMATCH[2]}"
        else
            selections+=("$_hash - $message: $commit_file")
        fi
    done < <(git --no-pager show --stat --oneline --name-only HEAD~${commit_count}..HEAD --)

    local fzf_output key selection commit_hash file file_path
    fzf_output=("$(printf "%s\\n" "${selections[@]}" | fzf --height='40%' -0 --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c')")
    key="$(command head -1 <<< "$fzf_output")"
    [[ -z "$key" ]] && key='default'
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    selection="$(command head -2 <<< "$fzf_output" | command tail -1)"
    commit_hash="$(echo $selection | awk '{ print $1 }')"
    file="$(echo $selection | awk '{ print $NF }')"
    file_path="${path}/${file}"

    # Turn off case-sensitivity for the following prompt.
    shopt -s nocasematch

    local answer checkout='false'
    while true; do
        # This fails without the '-n' flag.
        read -p "Do you want to checkout this commit_hash? (y/n): " -n 1 answer
        case "${answer}" in
            'y') echo $answer; checkout='true'; break ;;
            'n') echo $answer; break ;;
            *) echo $answer; printf "%s\\n" "Please answer [Y]es or [N]o (case insensitive)." ;;
        esac
    done
    # Turn case-sensitivity back on.
    shopt -u nocasematch

    local tool build_arguments
    if [[ "$checkout" == 'true' ]]; then
        tool="${EDITOR}"
        build_arguments='-k "$key" -t "$tool" -f "$file_path" -c "$commit_hash"'
    else
        # Fail gracefully if file doesn't exist in current branch.
        [[ -f "$file" ]] || { printf "%s\\n" "${file} doesn't exist in the working branch." 2>&1; return 1; }

        tool="git difftool --no-prompt ${commit_hash}"
        build_arguments='-k "$key" -t "$tool" -f "$file"'
        fi

        local _command
        _command="$(eval __build_edit_command "$build_arguments")"
        [[ $? -eq 1 ]] && return 1
        __ehc "$_command"
    }
builtin bind -x '"\C-_05": __fzf_open_file_at_commit'
builtin bind -m vi-insert '"\C-gcf": "\C-x0\C-_05\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gcf": "i\C-x0\C-_05\C-x1\C-x2\015"'


# Press "Ctrl-x + h" to open a file below the user HOME directory.
__fzf_file_open_home() {
    local cwd home
    cwd="$(pwd)"
    trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
    home="$(builtin eval echo ~)"
    builtin cd -- "$home"

    local selection key file
    selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
        command fzf --height='40%' -0 --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c')")
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then
        builtin cd -- "$cwd"
        return 127
    fi
    file="${home}/$(command head -2 <<< "$selection" | command tail -1)"

    [[ -d "$file" || ! -f "$file" ]] && { builtin cd -- "$cwd"; return 1; }

    local _command
    _command="$(__build_edit_command -k "$key" -t "$EDITOR" -f "$file")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    builtin cd -- "$cwd"

    [[ $key != 'alt-c' ]] && builtin cd -- "$cwd"
    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_06": __fzf_file_open_home'
builtin bind -m vi-insert '"\C-xh": "\C-x0\C-_06\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-xh": "i\C-x0\C-_06\C-x1\C-x2\015"'


# Press "Ctrl-x + /" and open a file below the root directory.
__fzf_file_open_root() {
    local cwd
    cwd="$(pwd)"
    trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
    builtin cd -- '/'

    local selection key file
    selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
        command fzf --height='40%' -0 --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c')")
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then
        builtin cd -- "$cwd"
        return 127
    fi
    file="/$(command head -2 <<< "$selection" | command tail -1)"

    [[ -d "$file" || ! -f "$file" ]] && { builtin cd -- "$cwd"; return 1; }

    local _command
    _command="$(__build_edit_command -k "$key" -t "$EDITOR" -f "$file")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    builtin cd -- "$cwd"

    [[ $key != 'alt-c' ]] && builtin cd -- "$cwd"
    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_07": __fzf_file_open_root'
builtin bind -m vi-insert '"\C-x/": "\C-x0\C-_07\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x/": "i\C-x0\C-_07\C-x1\C-x2\015"'


# Press "Ctrl-x + Ctrl-f" to search file contents and open a file at the selected line.
__fzf_grep() {
    local cwd
    cwd="$(pwd)"
    trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
    local dir=""
    if git rev-parse --show-toplevel &>/dev/null; then
        dir="$(git rev-parse --show-toplevel)"
        builtin cd -- "$dir"
    fi

    local selection key
    selection=("$(command rg -n -L --ignore-file $(builtin eval echo ~)/.gitignore_global . 2>/dev/null |
        command fzf --height='40%' -0 --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c')")
        key="$(command head -1 <<< "$selection")"
        if [[ "$key" == 'ctrl-c' ]]; then return 127; fi

        local awkcommand
        if command -v gawk &>/dev/null; then awkcommand='gawk'; else awkcommand='awk'; fi

        local tokens
        tokens="$(builtin echo "${selection[@]}" | command $awkcommand -F: '{ print $1, $2}')"

        local file line
        builtin read -r file line <<< "$(command head -2 <<< "$tokens" | command tail -1)"
        [[ $line =~ ^[0-9]+$ ]] || { builtin printf "%s\\n" "fzf_bindings: detected wrong line number format. Terminating."; return 1; }

        local path
        if [[ -n "$dir" ]]; then
            path="${dir}/${file}"
        else
            path="${file}"
        fi

        [[ -f "$path" ]] || { builtin cd -- "$cwd"; return 1; }

        local _command
        _command="$(__build_edit_command -k "$key" -t "$EDITOR" -f "$path" -l "$line")"
        [[ $? -eq 1 ]] && return 1
        __ehc "$_command"

        [[ $key != 'alt-c' ]] && builtin cd -- "$cwd"
        trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_08": __fzf_grep'
builtin bind -m vi-insert '"\C-x\C-f": "\C-x0\C-_08\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x\C-f": "i\C-x0\C-_08\C-x1\C-x2\015"'


__build_cd_command() {
    local key directory
    key="$1"
    directory="$2"

    local executable _return=0
    case $key in
        'ctrl-o') executable="${OPENER} ${directory} &" ;;
        'ctrl-x') if [[ -n "$TMUX" ]]; then executable="tmux split-window -v -c ${directory}"; else _return=1; fi ;;
        'ctrl-v') if [[ -n "$TMUX" ]]; then executable="tmux split-window -h -c ${directory}"; else _return=1; fi ;;
        'ctrl-t') if [[ -n "$TMUX" ]]; then executable="tmux new-window -c ${directory}"; else _return=1; fi ;;
        *) executable="builtin cd -- ${directory}" ;;

    esac

    [[ $_return -eq 1 ]] && { builtin printf "%s\\n" "tmux: Tmux session not detected." 2>&1; return 1; }
    builtin echo "$executable"
}


# When inside a Git project, press Alt-g to jump to any directory in the project.
__fzf_cd_git() {
    trap '__catch_interrupt' ERR INT TERM QUIT
    if git rev-parse --show-toplevel &>/dev/null; then
        local proot
        proot="$(git rev-parse --show-toplevel)"
    else
        builtin printf "%s\\n" "Git project not detected." 2>&1
        return 1
    fi

    local selection key dir
    selection=("$(command find -L "$proot" \( -path '*/\.git' -o -fstype dev -o -fstype proc \) -prune \
        -o -type d -print 2>/dev/null |
        command sed "s#${proot}/##" |
        command sed '1d; s#^\./##' |
        command fzf --height='40%' -0 --no-multi --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c')")
    [[ -n $selection ]] || return 1
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    dir="$(command head -2 <<< "$selection" | command tail -1)"

    local path
    path="${proot}/${dir}"
    [[ -d "$path" ]] || return 1

    local _command
    _command="$(__build_cd_command "$key" "$path")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_09": __fzf_cd_git'
builtin bind -m vi-insert '"\M-g": "\C-x0\C-_09\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-g": "i\C-x0\C-_09\C-x1\C-x2\015"'


# Press Alt-h to jump to any directory below the current working directory, including hidden directories.
__fzf_cd_all() {
    trap '__catch_interrupt' ERR INT TERM QUIT
    local selection key dir

    selection=("$(command find -L . \( -fstype dev -o -fstype proc \) -prune \
        -o -type d -print 2>/dev/null |
        command sed '1d; s#^\./##' |
        command fzf --height='40%' -0 --no-multi --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c')")
    [[ -n $selection ]] || return 1
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    dir="$(command head -2 <<< "$selection" | command tail -1)"

    path="$(pwd)/${dir}"
    [[ -d "$path" ]] || return 1

    local _command
    _command="$(__build_cd_command "$key" "$path")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_10": __fzf_cd_all'
builtin bind -m vi-insert '"\M-h": "\C-x0\C-_10\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-h": "i\C-x0\C-_10\C-x1\C-x2\015"'


# Press Alt-r to jump to any directory below the root directory.
__fzf_cd_root() {
    trap '__catch_interrupt' ERR INT TERM QUIT
    local selection key dir
    selection=("$(command find -L / \( -fstype dev -o -fstype proc \) -prune \
        -o -type d -print 2>/dev/null |
        command sed '1d; s#^\./##' |
        command fzf --height='40%' -0 --no-multi --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c')")
    [[ -n $selection ]] || return 1
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    dir="$(command head -2 <<< "$selection" | command tail -1)"

    [[ -d "$dir" ]] || return 1

    local _command
    _command="$(__build_cd_command "$key" "$dir")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_11": __fzf_cd_root'
builtin bind -m vi-insert '"\M-r": "\C-x0\C-_11\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-r": "i\C-x0\C-_11\C-x1\C-x2\015"'


# Press Alt-p to jump a parent directory.
__fzf_cd_parent() {
    trap '__catch_interrupt' ERR INT TERM QUIT
    declare directories=()
    get_parent_directories() {
        if [[ -d "$1" ]]; then directories+=("$1"); else return 1; fi

        if [[ $1 == '/' ]]; then
            local directory
            for directory in "${directories[@]}"; do builtin echo "$directory"; done
        else
            get_parent_directories "$(dirname "$1")"
        fi
    }

    local selection key directory
    selection=("$(get_parent_directories "$(realpath "${1:-$PWD}")" |
    command fzf --height='40%' -0 --tac --no-multi --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c')")
    [[ -n $selection ]] || return 1
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    directory="$(command head -2 <<< "$selection" | command tail -1)"

    [[ -d "$directory" ]] || return 1

    local _command
    _command="$(__build_cd_command "$key" "$directory")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_12": __fzf_cd_parent'
builtin bind -m vi-insert '"\M-P": "\C-x0\C-_12\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-P": "i\C-x0\C-_12\C-x1\C-x2\015"'


# Press "Alt-b" to bookmark the current working directory (not stateful across terminals).
__bookmark() {
    # Return if the directory has already been bookmarked.
    if builtin dirs -v | command grep -v " 0" | command grep -q -s "$(command pwd)"; then
        return 1
    fi

    _command="builtin pushd . 2>/dev/null"

    __ehc "$_command"
}
builtin bind -x '"\C-_13": __bookmark'
builtin bind -m vi-insert '"\M-b": "\C-x0\C-_13\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-b": "i\C-x0\C-_13\C-x1\C-x2\015"'


# Press Alt-k to navigate to a bookmarked directory.
__fzf_goto_bookmark() {
    trap '__catch_interrupt' ERR INT TERM QUIT
    local awkcommand
    if command -v gawk &>/dev/null; then awkcommand='gawk'; else awkcommand='awk'; fi

    local selection home
    home="$(builtin eval echo ~)"
    selection=("$(builtin dirs -v |
        grep -v " 0" |
        command $awkcommand "{ gsub(/~/, \"${home}\"); print \$2 }" |
        command fzf --height='40%' -0 --no-multi --expect='ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c')")
    [[ -n $selection ]] || return 1
    local key directory
    key="$(command head -1 <<< "$selection")"
    if [[ "$key" == 'ctrl-c' ]]; then return 127; fi
    directory="$(command head -2 <<< "$selection" | command tail -1)"

    [[ -d "$directory" ]] || return 1

    local _command
    _command="$(__build_cd_command "$key" "$directory")"
    [[ $? -eq 1 ]] && return 1
    __ehc "$_command"

    trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_14": __fzf_goto_bookmark'
builtin bind -m vi-insert '"\M-k": "\C-x0\C-_14\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-k": "i\C-x0\C-_14\C-x1\C-x2\015"'
