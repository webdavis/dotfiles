# shellcheck shell=bash
# shellcheck disable=SC1090
# vi: set filetype=sh:

export FZF_BINDINGS_EXIT_CODE=0
export FZF_BINDINGS_GIT_LOG_LIMIT=500

if [[ -x "$(builtin command -v rg)" ]]; then
  FZF_DEFAULT_COMMAND='rg --files --no-ignore -L -g "!.git/" 2>/dev/null'
elif [[ -x "$(builtin command -v ag)" ]]; then
  FZF_DEFAULT_COMMAND='ag -u --ignore ".git" -l -g ""'
else
  FZF_DEFAULT_COMMAND='find . -path "*/\.*" -prune -o -type f -print -o -type l -print | sed s/^..// 2>/dev/null'
fi
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

# Show command history with short command descriptions in the preview window.
export FZF_CTRL_R_OPTS="--preview='echo {} | cut -d"'" "'" -f3 | xargs whatis' --preview-window=down:5"

FZF_DEFAULT_OPTS="--reverse "
FZF_DEFAULT_OPTS+="-m "
FZF_DEFAULT_OPTS+="--cycle "

# Note: bat provides syntax highlighting.
FZF_DEFAULT_OPTS+="--preview='(file --mime {} | grep -q -s empty && echo \$(basename {}): is empty.) ||
    (file --mime {} | grep -q -s binary && echo \$(basename {}): is a binary file.) ||
    (bat --style=numbers --color=always {} | head -500)' "
FZF_DEFAULT_OPTS+='--preview-window="down:50%:hidden" '

# Keyboard mappings.
FZF_DEFAULT_OPTS+='--bind="?:toggle-preview" '
FZF_DEFAULT_OPTS+='--bind="ctrl-n:down" '
FZF_DEFAULT_OPTS+='--bind="ctrl-p:up" '
FZF_DEFAULT_OPTS+='--bind="ctrl-alt-p:page-up" '
FZF_DEFAULT_OPTS+='--bind="ctrl-alt-n:page-down" '
FZF_DEFAULT_OPTS+='--bind="change:top" '
FZF_DEFAULT_OPTS+='--bind="ctrl-r:toggle-sort" '
FZF_DEFAULT_OPTS+='--bind="ctrl-g:kill-line" '

# Colorscheme:
export FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS \
--color=fg:#c0caf5,bg:#1a1b26,hl:#ff9e64 \
--color=fg+:#c0caf5,bg+:#292e42,hl+:#ff9e64 \
--color=info:#7aa2f7,prompt:#7dcfff,pointer:#7dcfff \
--color=marker:#9ece6a,spinner:#9ece6a,header:#9ece6a"

export FZF_COMPLETION_OPTS="--height='40%'"

# The command that opens default applications depending on the mime type of the file.
if [[ "$(uname -s)" == "Darwin" ]]; then
  OPENER="$(command -v open)"
else
  OPENER="$(command -v xdg-open)"
fi
export OPENER

if [[ $EDITOR =~ homebrew ]]; then
  EDITOR_CMD="nvim"
fi

builtin bind '"\C-x0": kill-whole-line'     # Clears the entire line.
builtin bind '"\C-x1": magic-space'         # Performs history expansion and inserts a space.
builtin bind '"\C-x2": redraw-current-line' # Refreshes the current line.

# Prints the command to the console so itâ€™s recorded in .bash_history.
__insert_text_at_cursor() {
  READLINE_LINE="${READLINE_LINE:+${READLINE_LINE:0:READLINE_POINT}}${1}${READLINE_LINE:+${READLINE_LINE:READLINE_POINT}}"
  READLINE_POINT="$((READLINE_POINT + ${#1}))"
}

__build_edit_command() {
  local key="default"
  local tool=""
  local file=""
  local line=""
  local checkout=""

  local optstring=":c:f:k:l:t:" option
  while getopts "$optstring" option; do
    case $option in
      c) checkout="git checkout ${OPTARG};" ;;
      f) file="${OPTARG}" ;;
      k) key="${OPTARG}" ;;
      l) line="+${OPTARG}" ;;
      t) tool="${OPTARG}" ;;
      *)
        builtin printf "%s\n" "Error: Unknown fzf_bindings flag '$OPTARG'. Terminating!"
        return 1
        ;;
    esac
  done

  # Build the command:
  local cmd=""
  [[ -n $tool ]] && cmd="$tool"
  [[ -n $file ]] && cmd="${cmd} ${file}"
  [[ -n $checkout ]] && cmd="${checkout} ${cmd}"
  [[ -n $line ]] && cmd="${cmd} ${line}"

  local tmux_error_msg="Error: Tmux session not detected. Terminating fzf_bindings!"

  # Choose the operation.
  case $key in
    "alt-c")
      cmd="builtin cd ${file%/*}"
      if [[ -n $checkout ]]; then
        cmd="${checkout} ${cmd}"
      fi
      ;;
    "ctrl-o")
      if [[ -n $OPENER ]]; then
        cmd="${OPENER} '$file'"
      else
        # Attempt to determine open-utility on the fly.
        local os kernel_name
        kernel_name="$(command uname -s)"
        case "${kernel_name}" in
          "Linux" | "GNU"*)
            os="linux"
            ;;
          "Darwin")
            os="$(command sw_vers -productName)"
            ;;
          *"BSD")
            os="bsd"
            ;;
          "CYGWIN"* | "MSYS"* | "MINGW"*)
            os="windows"
            ;;
          "SunOS")
            os="solaris"
            ;;
          *)
            os="unknown"
            ;;
        esac
        case "${os}" in
          "linux" | "bsd")
            cmd="xdg-open '$file'"
            ;;
          "macOS")
            cmd="open \"$file\""
            ;;
          "windows")
            cmd="start '$file'"
            ;;
          *)
            printf "%s\n" "Error: Unknown Operating System detected: '${kernel_name}'. Terminating fzf_bindings!" 1>&2
            return 1
            ;;
        esac
      fi
      ;;
    "ctrl-s")
      cmd="sudo ${cmd}"
      ;;
    "ctrl-x")
      if [[ -z $TMUX ]]; then
        builtin printf "%s\n" "$tmux_error_msg" 2>&1
        return 1
      fi
      cmd="tmux split-window -v \"${cmd}; exec bash\""
      ;;
    "ctrl-v")
      if [[ -z $TMUX ]]; then
        builtin printf "%s\n" "$tmux_error_msg" 2>&1
        return 1
      fi
      cmd="tmux split-window -h \"${cmd}; exec bash\""
      ;;
    "ctrl-t")
      [[ -n $TMUX ]] || {
        builtin printf "%s\n" "$tmux_error_msg" 2>&1
        return 1
      }
      cmd="tmux new-window \"${cmd}; exec bash\""
      ;;
  esac

  builtin printf "%s\n" "$cmd"
}

__catch_interrupt() {
  trap '' ERR INT TERM QUIT
  [[ -n $1 ]] && builtin cd -- "$1" || return "$?"
}

# "<C-x><C-x>" open a file below the <cwd>.
__fzf_file_open() {
  local cwd selection key file
  cwd="$(pwd)"
  selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
    command fzf --height="40%" -0 --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c")")
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  file="$(command head -2 <<<"$selection" | command tail -1)"

  local path
  if [[ -n $dir ]]; then
    path="${dir}/${file}"
  else
    path="${file}"
  fi

  [[ -f $path ]] || {
    builtin cd -- "$cwd" || return "$?"
  }

  local _command
  _command="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$path")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"
}
builtin bind -x '"\C-_00": __fzf_file_open'
builtin bind -m vi-insert '"\C-x\C-x": "\C-x0\C-_00\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x\C-x": "i\C-x0\C-_00\C-x1\C-x2\015"'

# "<C-x>x" - open any *file* under the project root.
__fzf_open_any_file_under_project_root() {
  local cwd
  cwd="$(pwd)"
  trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
  local dir=""
  if git rev-parse --show-toplevel &>/dev/null; then
    dir="$(git rev-parse --show-toplevel)"
    builtin cd -- "$dir" || return "$?"
  else
    builtin printf "%s\n" "__fzf_project_file_open: Not in a git-tracked project" 2>&1
    return 1
  fi

  local selection key file
  selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
    command fzf --height="40%" -0 --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c")")
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then
    builtin cd -- "$cwd" || return 127
  fi
  file="$(command head -2 <<<"$selection" | command tail -1)"

  local path
  if [[ -n $dir ]]; then
    path="${dir}/${file}"
  else
    path="${file}"
  fi

  [[ -f $path ]] || {
    builtin cd -- "$cwd" || return "$?"
  }

  local _command
  _command="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$path")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  builtin cd -- "$cwd" || return "$?"

  [[ $key != "alt-c" ]] && builtin cd -- "$cwd" || return "$?"
  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_01": __fzf_open_any_file_under_project_root'
builtin bind -m vi-insert '"\C-xx": "\C-x0\C-_01\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-xx": "i\C-x0\C-_01\C-x1\C-x2\015"'

__fzf_bindings_set_exit_code() {
  FZF_BINDINGS_EXIT_CODE=$1
  return "$FZF_BINDINGS_EXIT_CODE"
}

__fzf_bindings_get_git_root() {
  local root
  local exit_code=1

  if ! root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
    printf "Warning: '%s' couldn't detect a Git project.\n" "${FUNCNAME[1]}" >&2
    __fzf_bindings_set_exit_code "$exit_code" || return "$exit_code"
  fi

  printf '%s' "$root"
}

__fzf_bindings_check_interrupt() {
  local key="$1"

  local interrupt_code=127

  if [[ "$key" == "ctrl-c" ]]; then
    __fzf_bindings_set_exit_code "$interrupt_code"
    return "$interrupt_code"
  fi

  return 0
}

# "<C-g>f" - open any git-tracked file in the project.
__fzf_git_file_open() {
  local project_root
  project_root="$(__fzf_bindings_get_git_root)" || return

  local -r fzf_keys="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c"
  local -r fzf_height_40="40%"

  local -a selection
  mapfile -t selection < <(
    git -C "$project_root" ls-files |
      fzf --height="$fzf_height_40" -0 --expect="$fzf_keys"
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return

  local file="${selection[1]}"
  if [[ -z "$file" ]]; then
    __fzf_bindings_set_exit_code 1
    return
  fi

  local realpath_cmd
  if command realpath --version &>/dev/null 2>&1; then
    realpath_cmd="$(command -v realpath)"
  else
    realpath_cmd="$(command -v grealpath || true)"
  fi

  local path="${project_root}/${file}"
  [[ -n $realpath_cmd ]] && path="$($realpath_cmd --relative-to="$(pwd)" "$path")"

  if [[ ! -f "$path" ]]; then
    __fzf_bindings_set_exit_code 1
    return
  fi

  local cmd
  cmd="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$path")" || {
    __fzf_bindings_set_exit_code 1
    return
  }

  __insert_text_at_cursor "$cmd"
}
builtin bind -x '"\C-_15": __fzf_git_file_open'
builtin bind -m vi-insert '"\C-gf": "\C-x0\C-_15\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gf": "i\C-x0\C-_15\C-x1\C-x2\015"'

# "<C-g>H" - search and select a git commit hash.
__fzf_search_git_commit_hashes() {
  __fzf_bindings_get_git_root || return

  local -r fzf_keys="ctrl-c"
  local -r fzf_height_60="60%"
  local -r fzf_preview_implementation='echo "Commit: {1}" && echo && git show --color=always --format=fuller --stat {1}'
  local -r fzf_preview_window="down:50%:wrap"

  local -a selection
  mapfile -t selection < <(
    git log --oneline -n "$FZF_BINDINGS_GIT_LOG_LIMIT" |
      fzf \
        --multi \
        --height="$fzf_height_60" \
        --preview "$fzf_preview_implementation" \
        --preview-window="$fzf_preview_window" \
        -0 \
        --expect="$fzf_keys"
  )

  __fzf_bindings_check_interrupt "${selection[0]}" || return

  local -a commit_hashes
  local -r hash_regex='^[0-9a-f]{7,40}'
  local line
  for line in "${selection[@]:1}"; do
    if [[ $line =~ $hash_regex ]]; then
      commit_hashes+=("${BASH_REMATCH[0]}")
    fi
  done

  if [[ ${#commit_hashes[@]} -eq 0 ]]; then
    __fzf_bindings_set_exit_code 1
    return
  fi

  __insert_text_at_cursor "${commit_hashes[*]}"
}
builtin bind -x '"\C-_02": __fzf_search_git_commit_hashes'
builtin bind -m vi-insert '"\C-gH": "\C-_02"'
builtin bind -m vi-command '"\C-gH": "i\C-_02"'

# "<C-g>ch" - `git checkout` a commit.
__fzf_git_checkout_commit() {
  if git rev-parse --show-toplevel &>/dev/null; then
    local path
    path="$(git rev-parse --show-toplevel)"
  else
    builtin printf "%s\n" "__fzf_checkout_commit: Git project not detected." 2>&1
    return 1
  fi

  local fzf_output key selection commit_hash file file_path
  fzf_output=("$(git log --oneline | fzf --height="40%" -0 --expect="ctrl-x,ctrl-v,ctrl-t,ctrl-c")")
  key="$(command head -1 <<<"$fzf_output")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  [[ -z $key ]] && key="default"
  selection="$(command head -2 <<<"$fzf_output" | command tail -1)"
  commit_hash="$(echo "$selection" | awk '{ print $1 }')"

  # Verify the commit hash.
  local hash_regex='^[0-9a-f]{7,40}'
  if [[ $commit_hash =~ $hash_regex ]]; then
    commit_hash="${BASH_REMATCH[@]}"
  fi

  local _command
  _command="$(__build_edit_command -k "$key" -c "$commit_hash")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"
}
builtin bind -x '"\C-_03": __fzf_git_checkout_commit'
builtin bind -m vi-insert '"\C-gch": "\C-x0\C-_03\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gch": "i\C-x0\C-_03\C-x1\C-x2\015"'

# "<C-g>cb" - `git checkout <branch>`
__fzf_checkout_branch() {
  if git rev-parse --show-toplevel &>/dev/null; then
    local path
    path="$(git rev-parse --show-toplevel)"
  else
    builtin printf "%s\n" "Git project not detected." 2>&1
    return 1
  fi

  local fzf_output key selection commit_hash file file_path
  fzf_output=("$(git branch | fzf --height="40%" -0 --expect="ctrl-x,ctrl-v,ctrl-t,ctrl-c" | tr -d "[:space:]")")
  key="$(command head -1 <<<"$fzf_output")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  [[ -z $key ]] && key="default"
  selection="$(command head -2 <<<"$fzf_output" | command tail -1)"
  commit_hash="$(echo "$selection" | awk '{ print $1 }')"

  # Verify the commit hash.
  local hash_regex='^[0-9a-f]{7,40}'
  if [[ $commit_hash =~ $hash_regex ]]; then
    commit_hash="${BASH_REMATCH[@]}"
  fi

  local _command
  _command="$(__build_edit_command -k "$key" -c "$commit_hash")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"
}
builtin bind -x '"\C-_04": __fzf_checkout_branch'
builtin bind -m vi-insert '"\C-gcb": "\C-x0\C-_04\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gcb": "i\C-x0\C-_04\C-x1\C-x2\015"'

# "<C-g>cf" - open a file from the previous commit.
__fzf_open_file_at_commit() {
  if git rev-parse --show-toplevel &>/dev/null; then
    local path
    path="$(git rev-parse --show-toplevel)"
  else
    builtin printf "%s\n" "__fzf_open_file_at_commit: Git project not detected." 2>&1
    return 1
  fi

  # Get number of commits.
  local commit_count
  commit_count="$(git rev-list --no-merges --count HEAD --)"
  commit_count=$((commit_count - 1))

  # Build array of file diffs paired with their respective commit hashes.
  local selections hash_regex commit_file _hash message
  hash_regex='(^[0-9a-f]{7,40})\ (.*)'
  while read -r commit_file; do
    if [[ $commit_file =~ $hash_regex ]]; then
      _hash="${BASH_REMATCH[1]}"
      message="${BASH_REMATCH[2]}"
    else
      selections+=("$_hash - $message: $commit_file")
    fi
  done < <(git --no-pager show --stat --oneline --name-only HEAD~${commit_count}..HEAD --)

  local fzf_output key selection commit_hash file file_path
  fzf_output=("$(printf "%s\n" "${selections[@]}" | fzf --height="40%" -0 --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c")")
  key="$(command head -1 <<<"$fzf_output")"
  [[ -z $key ]] && key="default"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  selection="$(command head -2 <<<"$fzf_output" | command tail -1)"
  commit_hash="$(echo "$selection" | awk '{ print $1 }')"
  file="$(echo "$selection" | awk '{ print $NF }')"
  file_path="${path}/${file}"

  # Turn off case-sensitivity for the following prompt.
  shopt -s nocasematch

  local answer checkout="false"
  while true; do
    # This fails without the '-n' flag.
    read -r -p "Do you want to checkout this commit_hash? (y/n): " -n 1 answer
    case "${answer}" in
      "y")
        echo "$answer"
        checkout="true"
        break
        ;;
      "n")
        echo "$answer"
        break
        ;;
      *)
        echo "$answer"
        printf "%s\n" "Please answer [Y]es or [N]o (case insensitive)."
        ;;
    esac
  done
  # Turn case-sensitivity back on.
  shopt -u nocasematch

  local tool build_arguments
  if [[ $checkout == "true" ]]; then
    tool="$EDITOR_CMD"
    build_arguments='-k "$key" -t "$tool" -f "$file_path" -c "$commit_hash"'
  else
    # Fail gracefully if file doesn't exist in current branch.
    [[ -f $file ]] || {
      printf "%s\n" "${file} doesn't exist in the working branch." 2>&1
      return 1
    }

    tool="git difftool --no-prompt ${commit_hash}"
    build_arguments='-k "$key" -t "$tool" -f "$file"'
  fi

  local _command
  _command="$(eval __build_edit_command "$build_arguments")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"
}
builtin bind -x '"\C-_05": __fzf_open_file_at_commit'
builtin bind -m vi-insert '"\C-gcf": "\C-x0\C-_05\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gcf": "i\C-x0\C-_05\C-x1\C-x2\015"'

# "<C-x>h" - open a file below the home (~) directory.
__fzf_file_open_home() {
  local cwd home
  cwd="$(pwd)"
  trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
  home="$(builtin eval echo ~)"
  builtin cd -- "$home" || return "$?"

  local selection key file
  selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
    command fzf --height="40%" -0 --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c")")
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then
    builtin cd -- "$cwd" || return 127
  fi
  file="${home}/$(command head -2 <<<"$selection" | command tail -1)"

  [[ -d $file || ! -f $file ]] && {
    builtin cd -- "$cwd" || return "$?"
  }

  local _command
  _command="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$file")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  builtin cd -- "$cwd" || return "$?"

  [[ $key != "alt-c" ]] && builtin cd -- "$cwd" || return "$?"
  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_06": __fzf_file_open_home'
builtin bind -m vi-insert '"\C-xh": "\C-x0\C-_06\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-xh": "i\C-x0\C-_06\C-x1\C-x2\015"'

# "<C-x>/" - open a file below the root (/) directory.
__fzf_file_open_root() {
  local cwd
  cwd="$(pwd)"
  trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
  builtin cd -- '/' || return "$?"

  local selection key file
  selection=("$(FZF_DEFAULT_COMMAND="${FZF_DEFAULT_COMMAND}" \
    command fzf --height="40%" -0 --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c")")
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then
    builtin cd -- "$cwd" || return 127
  fi
  file="/$(command head -2 <<<"$selection" | command tail -1)"

  [[ -d $file || ! -f $file ]] && {
    builtin cd -- "$cwd" || return "$?"
  }

  local _command
  _command="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$file")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  builtin cd -- "$cwd" || return "$?"

  [[ $key != "alt-c" ]] && builtin cd -- "$cwd" || return "$?"
  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_07": __fzf_file_open_root'
builtin bind -m vi-insert '"\C-x/": "\C-x0\C-_07\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x/": "i\C-x0\C-_07\C-x1\C-x2\015"'

# "<C-x><C-f>" - open file at the selected line.
__fzf_grep() {
  local cwd
  cwd="$(pwd)"
  trap '__catch_interrupt "$cwd"' ERR INT TERM QUIT
  local dir=""
  if git rev-parse --show-toplevel &>/dev/null; then
    dir="$(git rev-parse --show-toplevel)"
    builtin cd -- "$dir" || return "$?"
  fi

  local selection key
  selection=("$(command rg -n -L --ignore-file $(builtin eval echo ~)/.gitignore_global . 2>/dev/null |
    command fzf --height="40%" -0 --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c")")
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi

  local awkcommand
  if command -v gawk &>/dev/null; then awkcommand="gawk"; else awkcommand="awk"; fi

  local tokens
  tokens="$(builtin echo "${selection[@]}" | command $awkcommand -F: '{ print $1, $2}')"

  local file line
  builtin read -r file line <<<"$(command head -2 <<<"$tokens" | command tail -1)"
  [[ $line =~ ^[0-9]+$ ]] || {
    builtin printf "%s\n" "fzf_bindings: detected wrong line number format. Terminating."
    return 1
  }

  local path
  if [[ -n $dir ]]; then
    path="${dir}/${file}"
  else
    path="${file}"
  fi

  [[ -f $path ]] || {
    builtin cd -- "$cwd" || return "$?"
  }

  local _command
  _command="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$path" -l "$line")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  [[ $key != "alt-c" ]] && builtin cd -- "$cwd" || return "$?"
  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_08": __fzf_grep'
builtin bind -m vi-insert '"\C-x\C-f": "\C-x0\C-_08\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x\C-f": "i\C-x0\C-_08\C-x1\C-x2\015"'

__build_cd_command_helper() {
  local key directory
  key="$1"
  directory="$2"

  local executable _return=0
  case $key in
    "ctrl-o") executable="${OPENER} ${directory} &" ;;
    "ctrl-x") if [[ -n $TMUX ]]; then executable="tmux split-window -v -c ${directory}"; else _return=1; fi ;;
    "ctrl-v") if [[ -n $TMUX ]]; then executable="tmux split-window -h -c ${directory}"; else _return=1; fi ;;
    "ctrl-t") if [[ -n $TMUX ]]; then executable="tmux new-window -c ${directory}"; else _return=1; fi ;;
    *) executable="builtin cd -- ${directory}" ;;

  esac

  [[ $_return -eq 1 ]] && {
    builtin printf "%s\n" "tmux: Tmux session not detected." 2>&1
    return 1
  }
  builtin echo "$executable"
}

# "<M-g>" - change to any directory in the project.
__fzf_cd_git() {
  trap '__catch_interrupt' ERR INT TERM QUIT
  if git rev-parse --show-toplevel &>/dev/null; then
    local proot
    proot="$(git rev-parse --show-toplevel)"
  else
    builtin printf "%s\n" "Git project not detected." 2>&1
    return 1
  fi

  local selection key dir
  selection=("$(command find -L "$proot" \( -path '*/\.git' -o -fstype dev -o -fstype proc \) -prune \
    -o -type d -print 2>/dev/null |
    command sed "s#${proot}/##" |
    command sed '1d; s#^\./##' |
    command fzf --height="40%" -0 --no-multi --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c")")
  [[ -n $selection ]] || return 1
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  dir="$(command head -2 <<<"$selection" | command tail -1)"

  local path
  path="${proot}/${dir}"
  [[ -d $path ]] || return 1

  local _command
  _command="$(__build_cd_command_helper "$key" "$path")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_09": __fzf_cd_git'
builtin bind -m vi-insert '"\M-g": "\C-x0\C-_09\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-g": "i\C-x0\C-_09\C-x1\C-x2\015"'

# "<M-h>" - change to directory below the <cwd> (including hidden directories).
__fzf_cd_all() {
  trap '__catch_interrupt' ERR INT TERM QUIT
  local selection key dir

  selection=("$(command find -L . \( -fstype dev -o -fstype proc \) -prune \
    -o -type d -print 2>/dev/null |
    command sed '1d; s#^\./##' |
    command fzf --height="40%" -0 --no-multi --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c")")
  [[ -n $selection ]] || return 1
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  dir="$(command head -2 <<<"$selection" | command tail -1)"

  path="$(pwd)/${dir}"
  [[ -d $path ]] || return 1

  local _command
  _command="$(__build_cd_command_helper "$key" "$path")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_10": __fzf_cd_all'
builtin bind -m vi-insert '"\M-h": "\C-x0\C-_10\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-h": "i\C-x0\C-_10\C-x1\C-x2\015"'

# "<M-r>" - change to directory below the root directory.
__fzf_cd_root() {
  trap '__catch_interrupt' ERR INT TERM QUIT
  local selection key dir
  selection=("$(command find -L / \( -fstype dev -o -fstype proc \) -prune \
    -o -type d -print 2>/dev/null |
    command sed '1d; s#^\./##' |
    command fzf --height="40%" -0 --no-multi --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c")")
  [[ -n $selection ]] || return 1
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  dir="$(command head -2 <<<"$selection" | command tail -1)"

  [[ -d $dir ]] || return 1

  local _command
  _command="$(__build_cd_command_helper "$key" "$dir")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_11": __fzf_cd_root'
builtin bind -m vi-insert '"\M-r": "\C-x0\C-_11\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-r": "i\C-x0\C-_11\C-x1\C-x2\015"'

# "<M-p>" - change to a parent directory.
__fzf_cd_parent() {
  trap '__catch_interrupt' ERR INT TERM QUIT
  declare directories=()
  get_parent_directories() {
    if [[ -d $1 ]]; then directories+=("$1"); else return 1; fi

    if [[ $1 == '/' ]]; then
      local directory
      for directory in "${directories[@]}"; do builtin echo "$directory"; done
    else
      get_parent_directories "$(dirname "$1")"
    fi
  }

  local selection key directory
  selection=("$(get_parent_directories "$(realpath "${1:-$PWD}")" |
    command fzf --height="40%" -0 --tac --no-multi --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c")")
  [[ -n $selection ]] || return 1
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  directory="$(command head -2 <<<"$selection" | command tail -1)"

  [[ -d $directory ]] || return 1

  local _command
  _command="$(__build_cd_command_helper "$key" "$directory")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_12": __fzf_cd_parent'
builtin bind -m vi-insert '"\M-P": "\C-x0\C-_12\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-P": "i\C-x0\C-_12\C-x1\C-x2\015"'

# "<M-b>" - bookmark the <cwd> (not stateful across shell sessions).
__bookmark() {
  # Return if the directory has already been bookmarked.
  if builtin dirs -v | command grep -v " 0" | command grep -q -s "$(command pwd)"; then
    return 1
  fi

  _command="builtin pushd . 2>/dev/null"

  __insert_text_at_cursor "$_command"
}
builtin bind -x '"\C-_13": __bookmark'
builtin bind -m vi-insert '"\M-b": "\C-x0\C-_13\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-b": "i\C-x0\C-_13\C-x1\C-x2\015"'

# "<M-k>" - navigate to a bookmarked directory.
__fzf_cd_to_bookmarked_dir() {
  trap '__catch_interrupt' ERR INT TERM QUIT
  local awkcommand
  if command -v gawk &>/dev/null; then awkcommand="gawk"; else awkcommand="awk"; fi

  local selection home
  home="$(builtin eval echo ~)"
  selection=("$(builtin dirs -v |
    grep -v " 0" |
    command $awkcommand "{ gsub(/~/, \"${home}\"); print \$2 }" |
    command fzf --height="40%" -0 --no-multi --expect="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c")")
  [[ -n $selection ]] || return 1
  local key directory
  key="$(command head -1 <<<"$selection")"
  if [[ $key == "ctrl-c" ]]; then return 127; fi
  directory="$(command head -2 <<<"$selection" | command tail -1)"

  [[ -d $directory ]] || return 1

  local _command
  _command="$(__build_cd_command_helper "$key" "$directory")"
  [[ $? -eq 1 ]] && return 1
  __insert_text_at_cursor "$_command"

  trap '' ERR INT TERM QUIT
}
builtin bind -x '"\C-_14": __fzf_cd_to_bookmarked_dir'
builtin bind -m vi-insert '"\M-k": "\C-x0\C-_14\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-k": "i\C-x0\C-_14\C-x1\C-x2\015"'
