# shellcheck shell=bash
# shellcheck disable=SC1090
# vi: set filetype=sh:

export FZF_BINDINGS_EXIT_CODE=0
export FZF_BINDINGS_GIT_LOG_LIMIT=500
export FZF_BINDINGS_GIT_HASH_REGEX='^[0-9A-F]{7,40}'
export FZF_BINDINGS_HEIGHT='40%'
export FZF_BINDINGS_KEYS_GIT_CHECKOUT="ctrl-x,ctrl-v,ctrl-t,ctrl-c"
export FZF_BINDINGS_KEYS_OPEN="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-s,alt-c,ctrl-c"
export FZF_BINDINGS_KEYS_CD="ctrl-o,ctrl-x,ctrl-v,ctrl-t,ctrl-c"
export FZF_BINDINGS_KEYS_INTERRUPT="ctrl-c"

if command -v rg >/dev/null 2>&1; then
  FZF_DEFAULT_COMMAND='rg --files --no-ignore -L -g "!.git/" 2>/dev/null'
elif command -v ag >/dev/null 2>&1; then
  FZF_DEFAULT_COMMAND='ag -u --ignore ".git" -l -g ""'
else
  FZF_DEFAULT_COMMAND='find . -path "*/\.*" -prune -o -type f -print -o -type l -print | sed s/^..// 2>/dev/null'
fi
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

# Show command history with short command descriptions in the preview window.
export FZF_CTRL_R_OPTS="--preview='echo {} | cut -d"'" "'" -f3 | xargs whatis' --preview-window=down:5"

FZF_DEFAULT_OPTS="--reverse "
FZF_DEFAULT_OPTS+="-m "
FZF_DEFAULT_OPTS+="--cycle "

# Note: bat provides syntax highlighting.
FZF_DEFAULT_OPTS+="--preview='(file --mime {} | grep -q -s empty && echo \$(basename {}): is empty.) ||
    (file --mime {} | grep -q -s binary && echo \$(basename {}): is a binary file.) ||
    (bat --style=numbers --color=always {} | head -500)' "
FZF_DEFAULT_OPTS+='--preview-window="down:50%:hidden" '

# Keyboard mappings.
FZF_DEFAULT_OPTS+='--bind="?:toggle-preview" '
FZF_DEFAULT_OPTS+='--bind="ctrl-n:down" '
FZF_DEFAULT_OPTS+='--bind="ctrl-p:up" '
FZF_DEFAULT_OPTS+='--bind="ctrl-alt-p:page-up" '
FZF_DEFAULT_OPTS+='--bind="ctrl-alt-n:page-down" '
FZF_DEFAULT_OPTS+='--bind="change:top" '
FZF_DEFAULT_OPTS+='--bind="ctrl-r:toggle-sort" '
FZF_DEFAULT_OPTS+='--bind="ctrl-g:kill-line" '

# Colorscheme:
export FZF_DEFAULT_OPTS="$FZF_DEFAULT_OPTS \
--color=fg:#c0caf5,bg:#1a1b26,hl:#ff9e64 \
--color=fg+:#c0caf5,bg+:#292e42,hl+:#ff9e64 \
--color=info:#7aa2f7,prompt:#7dcfff,pointer:#7dcfff \
--color=marker:#9ece6a,spinner:#9ece6a,header:#9ece6a"

export FZF_COMPLETION_OPTS="--height='40%'"

# The command that opens default applications depending on the mime type of the file.
if [[ "$(uname -s)" == "Darwin" ]]; then
  OPENER="$(command -v open)"
else
  OPENER="$(command -v xdg-open)"
fi
export OPENER

EDITOR_CMD="${EDITOR_CMD:-$EDITOR}"
[[ $EDITOR =~ homebrew ]] && EDITOR_CMD="nvim"

builtin bind '"\C-x0": kill-whole-line'     # Clears the entire line.
builtin bind '"\C-x1": magic-space'         # Performs history expansion and inserts a space.
builtin bind '"\C-x2": redraw-current-line' # Refreshes the current line.

# Prints the command to the console so it’s recorded in .bash_history.
__insert_text_at_cursor() {
  READLINE_LINE="${READLINE_LINE:+${READLINE_LINE:0:READLINE_POINT}}${1}${READLINE_LINE:+${READLINE_LINE:READLINE_POINT}}"
  READLINE_POINT="$((READLINE_POINT + ${#1}))"
}

__build_edit_command() {
  local key="default"
  local tool=""
  local file=""
  local line=""
  local checkout=""

  local optstring=":c:f:k:l:t:" option
  while getopts "$optstring" option; do
    case $option in
      c) checkout="git checkout ${OPTARG};" ;;
      f) file="${OPTARG}" ;;
      k) key="${OPTARG}" ;;
      l) line="+${OPTARG}" ;;
      t) tool="${OPTARG}" ;;
      *)
        printf "Error: Unknown fzf_bindings flag '%s'. Terminating!\n" "$OPTARG" >&2
        return 1
        ;;
    esac
  done

  # Build the command:
  local cmd=""
  [[ -n $tool ]] && cmd="$tool"
  [[ -n $file ]] && cmd="${cmd} ${file}"
  [[ -n $checkout ]] && cmd="${checkout} ${cmd}"
  [[ -n $line ]] && cmd="${cmd} ${line}"

  local tmux_error_msg="Error: Tmux session not detected. Terminating fzf_bindings!"

  # Choose the operation.
  case $key in
    "alt-c")
      cmd="builtin cd ${file%/*}"
      if [[ -n $checkout ]]; then
        cmd="${checkout} ${cmd}"
      fi
      ;;
    "ctrl-o")
      if [[ -n $OPENER ]]; then
        cmd="${OPENER} '$file'"
      else
        # Attempt to determine open-utility on the fly.
        local os kernel_name
        kernel_name="$(command uname -s)"
        case "${kernel_name}" in
          "Linux" | "GNU"*)
            os="linux"
            ;;
          "Darwin")
            os="$(command sw_vers -productName)"
            ;;
          *"BSD")
            os="bsd"
            ;;
          "CYGWIN"* | "MSYS"* | "MINGW"*)
            os="windows"
            ;;
          "SunOS")
            os="solaris"
            ;;
          *)
            os="unknown"
            ;;
        esac
        case "${os}" in
          "linux" | "bsd")
            cmd="xdg-open '$file'"
            ;;
          "macOS")
            cmd="open \"$file\""
            ;;
          "windows")
            cmd="start '$file'"
            ;;
          *)
            printf "Error [%s]: Unknown Operating System detected: '${kernel_name}'." \
              "${FUNCNAME[1]}" "$kernel_name" >&2
            return 1
            ;;
        esac
      fi
      ;;
    "ctrl-s")
      cmd="sudo ${cmd}"
      ;;
    "ctrl-x")
      if [[ -z $TMUX ]]; then
        printf "%s\n" "$tmux_error_msg" >&2
        return 1
      fi
      cmd="tmux split-window -v \"${cmd}; exec bash\""
      ;;
    "ctrl-v")
      if [[ -z $TMUX ]]; then
        printf "%s\n" "$tmux_error_msg" >&2
        return 1
      fi
      cmd="tmux split-window -h \"${cmd}; exec bash\""
      ;;
    "ctrl-t")
      [[ -n $TMUX ]] || {
        printf "%s\n" "$tmux_error_msg" >&2
        return 1
      }
      cmd="tmux new-window \"${cmd}; exec bash\""
      ;;
  esac

  printf "%s\n" "$cmd"
}

__fzf_bindings_set_exit_code() {
  FZF_BINDINGS_EXIT_CODE=$1
  return "$FZF_BINDINGS_EXIT_CODE"
}

__fzf_bindings_get_git_root() {
  local root
  local exit_code=1

  if ! root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
    printf "Warning [%s]: Couldn't detect a Git project.\n" "${FUNCNAME[1]}" >&2
    __fzf_bindings_set_exit_code "$exit_code"
    return "$exit_code"
  fi

  printf "%s" "$root"
}

__fzf_bindings_check_interrupt() {
  local key="$1"

  local interrupt_code=127

  if [[ $key == "ctrl-c" ]]; then
    __fzf_bindings_set_exit_code "$interrupt_code"
    return "$interrupt_code"
  fi

  return 0
}

__fzf_bindings_verify_file_exists() {
  local file="$1"
  # Fail gracefully if file doesn't exist in current branch.

  local exit_code=1

  [[ -f $file ]] || {
    printf "Warning [%s]: Selected file '%s', which doesn't exist (in the working branch)" \
      "${FUNCNAME[1]}" "$file" >&2

    __fzf_bindings_set_exit_code "$exit_code"
    return "$exit_code"
  }

  return 0
}

__fzf_bindings_verify_directory_exists() {
  local directory="$1"
  # Fail gracefully if file doesn't exist in current branch.

  local exit_code=1

  [[ -d $directory ]] || {
    printf "Warning [%s]: selected directory '%s', which doesn't exist" \
      "${FUNCNAME[1]}" "$directory" >&2

    __fzf_bindings_set_exit_code "$exit_code"
    return "$exit_code"
  }

  return 0
}

__fzf_bindings_open_file() {
  local starting_directory="${1:-.}"
  local hidden=${2:-true}
  local preview="${3:-head -n 20 {}}"

  local -a find_cmd=("find" "$starting_directory" "-type" "f")

  [[ $hidden == true ]] && find_cmd+=("-name" ".*" "-print")

  case "$starting_directory" in / | "$HOME") find_cmd+=("-maxdepth" "2") ;; esac

  local -a selection
  mapfile -t selection < <(
    "${find_cmd[@]}" |
      sed 's|^\./||' |
      fzf -0 \
        --height="$FZF_BINDINGS_HEIGHT" \
        --expect="$FZF_BINDINGS_KEYS_OPEN" \
        ${preview:+--preview="$preview"}
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return 1

  local file="${selection[1]}"

  local cmd
  cmd="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$file")" || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  __insert_text_at_cursor "$cmd"
}

# "<C-x><C-x>" open a file below the <cwd>.
__fzf_open_file() {
  __fzf_bindings_open_file
}
builtin bind -x '"\C-_00": __fzf_open_file'
builtin bind -m vi-insert '"\C-x\C-x": "\C-x0\C-_00\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x\C-x": "i\C-x0\C-_00\C-x1\C-x2\015"'

# "<C-x>h" - open a file below the home (~) directory.
__fzf_open_home_file() {
  local home
  home="$(builtin eval echo ~)"
  __fzf_bindings_open_file "$home"
}
builtin bind -x '"\C-_06": __fzf_open_home_file'
builtin bind -m vi-insert '"\C-xh": "\C-x0\C-_06\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-xh": "i\C-x0\C-_06\C-x1\C-x2\015"'

# "<C-x>/" - open a file below the root (/) directory.
__fzf_open_root_file() {
  __fzf_bindings_open_file "/"
}
builtin bind -x '"\C-_07": __fzf_open_root_file'
builtin bind -m vi-insert '"\C-x/": "\C-x0\C-_07\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-x/": "i\C-x0\C-_07\C-x1\C-x2\015"'

# "<C-g><C-f>" - open file at the selected line.
__fzf_git_open_file_at_line() {
  local project_root
  project_root="$(__fzf_bindings_get_git_root)" || return 1

  local -a selection
  mapfile -t selection < <(
    git -C "$project_root" ls-files -z |
      xargs -0 rg -n -L --hidden --ignore-file "${project_root}/.gitignore" . 2>/dev/null |
      fzf --height="$FZF_BINDINGS_HEIGHT" -0 --expect="$FZF_BINDINGS_KEYS_OPEN"
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return 1

  local file line_number
  IFS=: read -r file line_number _ <<<"${selection[1]}"

  [[ $line_number =~ ^[0-9]+$ ]] || {
    printf "Error [%s]: Invalid line number '%s'. Must be a numeric value. Aborting.\n" \
      "${FUNCNAME[0]}" "$line_number" >&2
    __fzf_bindings_set_exit_code 1
    return 1
  }

  local cmd
  cmd="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$file" -l "$line_number")" || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  __insert_text_at_cursor "$cmd"
}
builtin bind -x '"\C-_08": __fzf_git_open_file_at_line'
builtin bind -m vi-insert '"\C-g\C-f": "\C-x0\C-_08\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-g\C-f": "i\C-x0\C-_08\C-x1\C-x2\015"'

__fzf_bindings_select_git_file() {
  local ls_files_args=("$@")

  local project_root
  project_root="$(__fzf_bindings_get_git_root)" || return 1

  local -a selection
  mapfile -t selection < <(
    git -C "$project_root" ls-files "${ls_files_args[@]}" |
      fzf -0 \
        --height="$FZF_BINDINGS_HEIGHT" \
        --expect="$FZF_BINDINGS_KEYS_OPEN" \
        --preview='head -n 20 {}'
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return 1

  local file="${selection[1]}"

  local realpath_cmd
  if command realpath --version &>/dev/null 2>&1; then
    realpath_cmd="$(command -v realpath)"
  else
    realpath_cmd="$(command -v grealpath || true)"
  fi

  local file_path="${project_root}/${file}"
  [[ -n $realpath_cmd ]] && file_path="$($realpath_cmd --relative-to="$(pwd)" "$file_path")"

  __fzf_bindings_verify_file_exists "$file_path" || return 1

  local cmd
  cmd="$(__build_edit_command -k "$key" -t "$EDITOR_CMD" -f "$file_path")" || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  __insert_text_at_cursor "$cmd"
}

# "<C-g>f" - open any git-tracked file in the project.
__fzf_git_open_tracked_file() {
  __fzf_bindings_select_git_file
}
builtin bind -x '"\C-_15": __fzf_git_open_tracked_file'
builtin bind -m vi-insert '"\C-gf": "\C-x0\C-_15\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gf": "i\C-x0\C-_15\C-x1\C-x2\015"'

# "<C-g>F" - open *any* file in a git project (tracked + untracked + ignored).
__fzf_git_open_any_file() {
  local git_ls_file_args=("--cached" "--others" "--exclude-standard")
  __fzf_bindings_select_git_file "${git_ls_file_args[@]}"
}
builtin bind -x '"\C-_01": __fzf_git_open_any_file'
builtin bind -m vi-insert '"\C-gF": "\C-x0\C-_01\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gF": "i\C-x0\C-_01\C-x1\C-x2\015"'

# "<C-g>H" - search and select a git commit hash.
__fzf_git_select_commit_hashes() {
  __fzf_bindings_get_git_root || return 1

  local -r fzf_preview_implementation='echo "Commit: {1}" && echo && git show --color=always --format=fuller --stat {1}'
  local -r fzf_preview_window="down:50%:wrap"

  local -a selection
  mapfile -t selection < <(
    git log --oneline -n "$FZF_BINDINGS_GIT_LOG_LIMIT" |
      fzf \
        --multi \
        --height="$FZF_BINDINGS_HEIGHT" \
        --preview "$fzf_preview_implementation" \
        --preview-window="$fzf_preview_window" \
        -0 \
        --expect="$FZF_BINDINGS_KEYS_INTERRUPT"
  )

  __fzf_bindings_check_interrupt "${selection[0]}" || return 1

  local -a commit_hashes
  local line
  for line in "${selection[@]:1}"; do
    if [[ $line =~ $FZF_BINDINGS_GIT_HASH_REGEX ]]; then
      commit_hashes+=("${BASH_REMATCH[0]}")
    fi
  done

  if [[ ${#commit_hashes[@]} -eq 0 ]]; then
    __fzf_bindings_set_exit_code 1
    return 1
  fi

  __insert_text_at_cursor "${commit_hashes[*]}"
}
builtin bind -x '"\C-_02": __fzf_git_select_commit_hashes'
builtin bind -m vi-insert '"\C-gH": "\C-_02"'
builtin bind -m vi-command '"\C-gH": "i\C-_02"'

# "<C-g>ch" - `git checkout` a commit.
__fzf_git_checkout_commit() {
  local project_root
  project_root="$(__fzf_bindings_get_git_root)" || return 1

  local -a selection
  mapfile -t selection < <(
    git log --oneline |
      fzf --height="$FZF_BINDINGS_HEIGHT" -0 --expect="$FZF_BINDINGS_KEYS_GIT_CHECKOUT"
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return 1

  [[ ${selection[1]} =~ $FZF_BINDINGS_GIT_HASH_REGEX ]] || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  local commit_hash="${BASH_REMATCH[0]}"

  cd "$project_root" || {
    __fzf_bindings_set_exit_code "$?"
    return 1
  }

  local cmd
  cmd="$(__build_edit_command -k "$key" -c "$commit_hash")" || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  __insert_text_at_cursor "$cmd"
}
builtin bind -x '"\C-_03": __fzf_git_checkout_commit'
builtin bind -m vi-insert '"\C-gch": "\C-x0\C-_03\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gch": "i\C-x0\C-_03\C-x1\C-x2\015"'

# "<C-g>cb" - `git checkout <branch>`
__fzf_git_checkout_branch() {
  local project_root
  project_root="$(__fzf_bindings_get_git_root)" || return 1

  local -a selection
  mapfile -t selection < <(
    git branch |
      fzf --height="$FZF_BINDINGS_HEIGHT" -0 --expect="$FZF_BINDINGS_KEYS_GIT_CHECKOUT" |
      tr -d "[:space:]"
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return 1

  cd "$project_root" || {
    __fzf_bindings_set_exit_code "$?"
    return 1
  }

  local cmd
  cmd="$(__build_edit_command -k "$key" -c "${selection[1]}")" || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  __insert_text_at_cursor "$cmd"
}
builtin bind -x '"\C-_04": __fzf_git_checkout_branch'
builtin bind -m vi-insert '"\C-gcb": "\C-x0\C-_04\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gcb": "i\C-x0\C-_04\C-x1\C-x2\015"'

# "<C-g>cf" - open a file from the previous commit.
__fzf_git_open_file_at_commit() {
  local project_root
  project_root="$(__fzf_bindings_get_git_root)" || return 1

  # Get number of commits:
  local commit_count
  commit_count="$(git rev-list --no-merges --count HEAD --)"
  ((commit_count--))

  local -a selection
  mapfile -t selection < <(
    git log --pretty=format:"%h|%s" --name-only HEAD~"$commit_count"..HEAD |
      awk -F'|' '/^[0-9a-f]{7,}\|/ { commit=$1; msg=$2; next } NF { print commit "  ╎" "|" $0 "|" "╎  " msg }' |
      column -t -s '|' |
      fzf --height="$FZF_BINDINGS_HEIGHT" -0 --expect="$FZF_BINDINGS_KEYS_OPEN"
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return 1

  local checkout=false
  local confirmation

  shopt -s nocasematch # Turn off case-sensitivity for the following prompt:
  while true; do
    read -r -p "Do you want to checkout this git commit? (y/n): " -n 1 confirmation
    echo
    case "${confirmation}" in
      y)
        checkout=true
        break
        ;;
      n)
        break
        ;;
      *)
        printf "%s\n" "Please answer [Y]es or [N]o (case insensitive)."
        ;;
    esac
  done
  shopt -u nocasematch # Turn case-sensitivity back on.

  local commit_hash file
  IFS='╎' read -r commit_hash file <<<"${selection[1]}"

  # Strip leading/trailing whitespace from each
  commit_hash="${commit_hash#"${commit_hash%%[![:space:]]*}"}"
  commit_hash="${commit_hash%"${commit_hash##*[![:space:]]}"}"

  file="${file#"${file%%[![:space:]]*}"}"
  file="${file%"${file##*[![:space:]]}"}"

  local file_path="${project_root}/${file_path}"

  local -a build_args

  if ((checkout)); then
    build_args=(-k "$key" -t "$EDITOR_CMD" -f "$file_path" -c "$commit_hash")
  else
    # Fail gracefully if file doesn't exist in current branch.
    __fzf_bindings_verify_file_exists "$file_path" || return 1

    build_args=(-k "$key" -t "git difftool --no-prompt ${commit_hash}" -f "$file_path")
  fi

  local cmd
  cmd="$(__build_edit_command "${build_args[@]}")" || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  __insert_text_at_cursor "$cmd"
}
builtin bind -x '"\C-_05": __fzf_git_open_file_at_commit'
builtin bind -m vi-insert '"\C-gcf": "\C-x0\C-_05\C-x1\C-x2\015"'
builtin bind -m vi-command '"\C-gcf": "i\C-x0\C-_05\C-x1\C-x2\015"'

__build_cd_command_helper() {
  local key directory
  key="$1"
  directory="$2"

  local executable exit_code=0
  case $key in
    "ctrl-o") executable="${OPENER} ${directory} &" ;;
    "ctrl-x") if [[ -n $TMUX ]]; then executable="tmux split-window -v -c ${directory}"; else exit_code=1; fi ;;
    "ctrl-v") if [[ -n $TMUX ]]; then executable="tmux split-window -h -c ${directory}"; else exit_code=1; fi ;;
    "ctrl-t") if [[ -n $TMUX ]]; then executable="tmux new-window -c ${directory}"; else exit_code=1; fi ;;
    *) executable="builtin cd -- \"${directory}\"" ;;

  esac

  ((exit_code)) && {
    printf "%s\n" "Error [tmux]: Session not detected." >&2
    return 1
  }

  printf "%s" "$executable"
}

__fzf_bindings_cd_helper() {
  local reverse_order="${1:-false}"
  shift

  local directories=("$@") # an array of directory paths
  local -a selection

  local fzf_opts=("-0" "--height=${FZF_BINDINGS_HEIGHT}" "--no-multi" "--expect=${FZF_BINDINGS_KEYS_CD}")
  ((reverse_order)) && fzf_opts+=("--tac")

  mapfile -t selection < <(
    printf '%s\n' "${directories[@]}" | fzf "${fzf_opts[@]}"
  )

  local key="${selection[0]}"
  __fzf_bindings_check_interrupt "$key" || return 1

  local directory_path="${selection[1]}"
  __fzf_bindings_verify_directory_exists "$directory_path" || return 1

  local cmd
  cmd="$(__build_cd_command_helper "$key" "$directory_path")" || {
    __fzf_bindings_set_exit_code 1
    return 1
  }

  __insert_text_at_cursor "$cmd"
}

# "<M-g>" - change to any directory in the project.
__fzf_cd_to_git_dir() {
  local project_root
  project_root="$(__fzf_bindings_get_git_root)" || return 1

  local -a directories
  mapfile -t directories < <(
    find -L "$project_root" \
      \( -path '*/\.git' -o -fstype dev -o -fstype proc \) -prune \
      -o -type d \
      -print 2>/dev/null
  )

  __fzf_bindings_cd_helper false "${directories[@]}"
}
builtin bind -x '"\C-_09": __fzf_cd_to_git_dir'
builtin bind -m vi-insert '"\M-g": "\C-x0\C-_09\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-g": "i\C-x0\C-_09\C-x1\C-x2\015"'

# "<M-h>" - change to directory below the <cwd> (including hidden directories).
__fzf_cd_below_cwd_including_hidden() {
  local -a directories
  mapfile -t directories < <(
    find -L . \
      \( -fstype dev -o -fstype proc \) -prune \
      -o -type d \
      -print 2>/dev/null |
      sed '1d; s#^\./##'
  )

  __fzf_bindings_cd_helper false "${directories[@]}"
}
builtin bind -x '"\C-_10": __fzf_cd_below_cwd_including_hidden'
builtin bind -m vi-insert '"\M-h": "\C-x0\C-_10\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-h": "i\C-x0\C-_10\C-x1\C-x2\015"'

# "<M-r>" - change to directory below the root directory.
__fzf_cd_from_root() {
  local -a directories
  mapfile -t directories < <(
    find -L / \
      \( -fstype dev -o -fstype proc \) -prune \
      -o -type d -print 2>/dev/null |
      sed '1d; s#^\./##'
  )

  __fzf_bindings_cd_helper false "${directories[@]}"
}
builtin bind -x '"\C-_11": __fzf_cd_from_root'
builtin bind -m vi-insert '"\M-r": "\C-x0\C-_11\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-r": "i\C-x0\C-_11\C-x1\C-x2\015"'

# "<M-p>" - change to a parent directory.
__fzf_cd_to_parent_dir() {
  local dir
  dir="$(realpath "${1:-$PWD}")"
  local directories=()

  while [[ $dir != "/" ]]; do
    directories+=("$dir")
    dir="$(dirname "$dir")"
  done
  directories+=("/")

  __fzf_bindings_cd_helper true "${directories[@]}"
}

builtin bind -x '"\C-_12": __fzf_cd_to_parent_dir'
builtin bind -m vi-insert '"\M-P": "\C-x0\C-_12\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-P": "i\C-x0\C-_12\C-x1\C-x2\015"'

# "<M-b>" - bookmark the <cwd> (not stateful across shell sessions).
__bookmark_cwd() {
  local cwd
  cwd="$(pwd)"

  # Return if the directory has already been bookmarked.
  if builtin dirs -p | tail -n +2 | grep -Fxq -- "$cwd"; then
    __fzf_bindings_set_exit_code || return 1
  fi

  __insert_text_at_cursor "builtin pushd . 2>/dev/null"
}
builtin bind -x '"\C-_13": __bookmark_cwd'
builtin bind -m vi-insert '"\M-b": "\C-x0\C-_13\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-b": "i\C-x0\C-_13\C-x1\C-x2\015"'

# "<M-k>" - navigate to a bookmarked directory.
__fzf_cd_to_bookmarked_dir() {
  local awkcommand
  if command -v gawk &>/dev/null; then
    awkcommand="gawk"
  else
    awkcommand="awk"
  fi

  local home
  home="$(builtin eval echo ~)"

  local -a directories
  mapfile -t directories < <(
    builtin dirs -v |
      grep -v " 0" |
      command $awkcommand "{ gsub(/~/, \"${home}\"); print \$2 }"
  )

  __fzf_bindings_cd_helper false "${directories[@]}"
}
builtin bind -x '"\C-_14": __fzf_cd_to_bookmarked_dir'
builtin bind -m vi-insert '"\M-k": "\C-x0\C-_14\C-x1\C-x2\015"'
builtin bind -m vi-command '"\M-k": "i\C-x0\C-_14\C-x1\C-x2\015"'
